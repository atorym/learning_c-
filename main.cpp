/*
- Тест        -------------------------------------------------------------------------------------------------------------

- Задание №1  -------------------------------------------------------------------------------------------------------------
 Объясните, когда следует использовать следующие типы умных указателей:

a) Умный указатель std::unique_ptr
 Когда необходимо использовать обычный указатель, указатель auto_ptr, при этом владельцем которого будет
 являтся лишь 1 обьект.

b) Умный указатель std::shared_ptr
 Когда необходимо использовать указатель, владельцем которого являются несколько обьектов.

c) Умный указатель std::weak_ptr
 Когда необходимо использовать указатель, который должен указывать на обьект, на который указывает shared_ptr,
 но который при этом не будет являтся его владельцем. Используется для того, чтобы избежать циклическую зависимость.

d) Умный указатель std::auto_ptr
 Указатель auto_ptr является устаревшим и его использовать не следует.


- Задание №2  -------------------------------------------------------------------------------------------------------------
 Объясните, как ссылки r-value участвуют в реализации семантики перемещения.

 Определение конструктора перемещения и оператора присваивания перемещением подразумевают использование ссылок r-value.
Семантика перемещения не работает с сылками l-value.
При использовании std::move ссылки l-value преобразуются в ссылки r-value.

 Семантика перемещения подразумевает то что значение одного обьекта "воруется" другим обьектом. А значения l-value могут
использоваться позже и мы не можем сказать что изменять их безопасно. Поэтому допустимо использовать только обьекты
r-value при перемещении, т.к. эти временные обьекты все равно будут уничтожены в конце выражения и никогда больше не
будут использованы.


- Задание №3 -------------------------------------------------------------------------------------------------------------
 Что не так со следующими программами? Обновите их в соответствии с рекомендациями, полученными в этой главе.

--------------------------------------------------------------------------------------------------------------------------
a) Оригинал:

#include <iostream>
#include <memory>// для std::shared_ptr


class Item {
public:
  Item() { std::cout << "Item acquired\n"; }
  ~Item() { std::cout << "Item destroyed\n"; }
};

int main() {
  Item* item = new Item;
  std::shared_ptr<Item> ptr1(item);
  std::shared_ptr<Item> ptr2(item);

  return 0;
}

--------------------------------------------------------------------------------------------------------------------------
                                                                                                                                                                                    Исправление:

#include <iostream>
#include <memory> // для std::shared_ptr

    class Item
{
public:
  Item() { std::cout << "Item acquired\n"; }
  ~Item() { std::cout << "Item destroyed\n"; }
};

int main()
{
  auto ptr1 = std::make_shared<Item>();
  std::shared_ptr<Item> ptr2 = ptr1;

  return 0;
}

--------------------------------------------------------------------------------------------------------------------------
b) Оригинал:

#include <iostream>
#include <memory> // для std::shared_ptr


class Something; // предположим, что Something - это класс, который может выбросить исключение

int main()
{
  doSomething(std::shared_ptr<Something>(new Something), std::shared_ptr<Something>(new Something));

  return 0;
}

--------------------------------------------------------------------------------------------------------------------------
                                                                                                                                                                                    Исправление:

#include <iostream>
#include <memory>// для std::shared_ptr


    class Something;// предположим, что Something - это класс, который может выбросить исключение

int main() {
  doSomething(std::make_shared<Something>(), std::make_shared<Something>());

  return 0;
}

--------------------------------------------------------------------------------------------------------------------------
                                                                                                                                                                                    */