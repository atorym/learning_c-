/*
Задание №3
Лучшим алгоритмом определения того, существует ли значение в отсортированном массиве или нет, является бинарный поиск.
Бинарный поиск работает следующим образом:
 Смотрим на центральный элемент массива.
 Если центральный элемент массива больше элемента, который мы ищем, то всё, что находится справа от центрального
элемента — отбрасываем.
 Если центральный элемент меньше элемента, который мы ищем, то отбрасываем всё, что находится слева от центрального элемента.
 Если центральный элемент равен элементу, который мы ищем, то возвращаем индекс этого элемента.
 Если перебрали весь массив и не нашли искомого значения, то возвращаем контрольное значение с выводом not found.
Поскольку в каждой итерации мы можем отбрасывать сразу половину массива, то скорость выполнения этого алгоритма достаточно
большая. Даже с массивом в миллион элементов для определения того, существует ли конкретное значение в этом массиве или нет,
потребуется не более 20 итераций! Однако бинарный поиск работает только в отсортированном массиве.
Изменение массива (например, отбрасывание половины элементов массива) является затратной операцией, поэтому обычно массив
не изменяется. Вместо этого используется два целочисленных значения (min и max) для хранения индексов минимальной и
максимальной границ поиска элемента в массиве. Рассмотрим пример работы этого алгоритма с массивом
{4, 5, 7, 10, 11, 14, 19, 20, 25} и искомым значением 7. Сначала min = 0, max = 8, так как мы перебираем весь массив
(всего элементов 9, но индекс последнего элемента равен 8).
 Итерация №1: Вычисляем среднее значение между min (0) и max (8), которое равно 4. Элемент №4 имеет значение 11,
которое больше нашего искомого значения. Поскольку массив отсортирован, то мы знаем, что все элементы, которые
находятся справа от индекса 4 (и индекс 4 тоже) являются больше нашего искомого числа. Поэтому min оставляем прежним,
а max изменяем на 3.
 Итерация №2: Вычисляем среднее значение между min (0) и max (3), которое равно 1. Элемент №1
имеет значение 5, которое меньше нашего искомого значения. Поскольку массив отсортирован, то мы знаем, что все элементы,
которые находятся слева от индекса 1 (и индекс 1 тоже) — меньше нашего искомого числа. Следовательно, min изменяем на 2,
а max оставляем прежним.
 Итерация №3: Вычисляем среднее значение между min (2) и max (3), которое равно 2. Элемент №2
имеет значение 7, которое является нашим искомым значением. Возвращаем элемент №2.

Используя следующий код:
 a) Напишите итеративную версию функции binarySearch().
 b) Напишите рекурсивную версию функции binarySearch().
 */

// array - это массив, в котором мы проводим поиски.
// target - это искомое значение.
// min - это индекс минимальной границы массива, в котором мы осуществляем поиск.
// max - это индекс максимальной границы массива, в котором мы осуществляем поиск.
// Функция binarySearch() должна возвращать индекс искомого значения, если он обнаружен. В противном случае, возвращаем -1

#include <cstdint>
#include <iostream>


//итеративная функция bynary_search
int binary_search_iterative(const int* array, int target, int min, int max) {
  while (true) {
    int half_of_array = (max + min) / 2;
    if (target == array[half_of_array]) {
      return half_of_array;
    }
    if (min == half_of_array || max == half_of_array) {
      return 0;
    }
    if (target > array[half_of_array]) {
      half_of_array += 1;
      min = half_of_array;
    } else {
      half_of_array -= 1;
      max = half_of_array;
    }
  }
}

//рекурсивная функция bynary_search
int binary_search_recursive(const int* array, int target, int min, int max) {
  int half_of_array = (max + min) / 2;
  if (target == array[half_of_array]) {
    return half_of_array;
  }
  if (min == half_of_array || max == half_of_array) {
    return 0;
  }
  if (target > array[half_of_array]) {
    half_of_array += 1;
    return binary_search_recursive(array, target, half_of_array, max);
  } else {
    half_of_array -= 1;
    return binary_search_recursive(array, target, min, half_of_array);
  }
}


int main() {
  int array[] = {4, 7, 9, 13, 15, 19, 22, 24,
    28, 33, 37, 41, 43, 47, 50};

  std::cout << "Enter a number: ";
  int x;
  std::cin >> x;

  //int index = binary_search_recursive(array, x, 0, 14);
  int index = binary_search_iterative(array, x, 0, 14);

  if (array[index] == x) {
    std::cout << "Good! Your value " << x << " is on position " << index << " in array!\n";
  } else {
    std::cout << "Fail! Your value " << x << " isn't in array!\n";
  }
  return EXIT_SUCCESS;
}